<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Собери карту России — Canvas-пазл (одна деталь, лидеры, Firebase)</title>
<style>
  :root{ --bg:#0d1427; --panel:#111a2e; --muted:#a9b7d6; --accent:#58e0b9; }
  html,body{height:100%;margin:0;background:var(--bg);color:#e7eeff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  *{ box-sizing:border-box; user-select:none; -webkit-user-select:none; -webkit-tap-highlight-color:transparent }
  .wrap{ max-width:1200px; margin:0 auto; padding:10px }
  .card{ background:var(--panel); border:1px solid #1d2745; border-radius:14px; padding:12px; box-shadow:0 8px 20px rgba(0,0,0,.25) }
  h1{ font-size:18px; margin:0 0 8px }
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .pill{ display:inline-flex; align-items:center; gap:6px; background:#0f1733; border:1px solid #223062; border-radius:999px; padding:6px 10px; font-size:12px; color:#cfe0ff }
  .btn{ background:#0f1733; border:1px solid #223062; color:#e7eeff; padding:8px 12px; border-radius:10px; cursor:pointer }
  .btn.primary{ background:linear-gradient(180deg,#36e1b3,#16c79a); color:#06251f; border:0; font-weight:700 }
  .input{ background:#0f1733; border:1px solid #223062; color:#e7eeff; padding:8px 10px; border-radius:10px; }
  select.input{ padding-right:28px }
  .muted{ color:var(--muted) } .small{ font-size:12px }
  .grid{ display:grid; grid-template-columns:1.4fr .6fr; gap:10px }
  @media (max-width: 980px){ .grid{ grid-template-columns:1fr } }
  .board{ display:grid; grid-template-columns:1fr; gap:10px }
  canvas{ width:100%; height:70vh; min-height:520px; background:#0a1127; border:1px solid #1d2747; border-radius:12px; display:block; touch-action:none }
  .tray{ background:#0a1127; border:1px dashed #2a3e73; border-radius:12px; padding:10px }
  .table{ width:100%; border-collapse:collapse; font-size:13px }
  .table th,.table td{ border-bottom:1px solid #1d2745; padding:6px 8px; text-align:left }
  .footer{ margin-top:12px; font-size:12px; color:#a9b7d6; text-align:center }
</style>
</head>
<body>
<div class="wrap">

  <div class="card">
    <h1>Онлайн-пазл «Карта России» (одна деталь за раз)</h1>
    <div class="row">
      <label>ФИО: <input id="fio" class="input" style="width:260px" placeholder="Иванов И.И."></label>
      <label>Номер группы: <input id="group" class="input" style="width:140px" placeholder="Гр-101"></label>
      <label>Сложность:
        <select id="difficulty" class="input">
          <option value="easy">Лёгкая</option>
          <option value="medium">Средняя</option>
          <option value="hard">Сложная</option>
        </select>
      </label>
      <button id="saveProfile" class="btn">Сохранить</button>
      <span class="pill">Поставлено: <b id="placed">0 / 89</b></span>
      <span class="pill">Время: <b id="time">00:00</b></span>
      <button id="reset" class="btn">Сбросить</button>
      <button id="help" class="btn">Подсказки</button>
      <span style="flex:1"></span>
      <button id="panToggle" class="btn">Режим карты: выкл</button>
      <button id="zoomOut" class="btn">−</button>
      <button id="zoomIn" class="btn">+</button>
    </div>
    <p class="muted small">Файл <code>Russian_regions_TopoJSON.topojson</code> должен лежать рядом со страницей. Сложность управляет «радиусом притягивания»: чем он меньше, тем точнее нужно поставить деталь.</p>
  </div>

  <div class="grid" style="margin-top:10px">
    <div class="board">
      <div class="card">
        <canvas id="cv" width="1000" height="680"></canvas>
        <div class="row muted small" style="margin-top:6px; justify-content:space-between">
          <span id="status" class="pill">Загрузка карты…</span>
        </div>
      </div>
    </div>
    <div class="board">
      <div class="card tray">
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div>
            <div class="small muted">Текущий субъект:</div>
            <div id="currentName" style="font-weight:700; margin-top:2px">—</div>
          </div>
          <button id="takePiece" class="btn">Взять деталь</button>
        </div>
        <canvas id="tray" width="360" height="220" style="margin-top:10px; width:100%; height:220px; background:#0b132b; border:1px solid #1b2953; border-radius:10px"></canvas>
        <div class="small muted" style="margin-top:6px">Подсказка: нажмите «Взять деталь» или кликните по области «лотка», затем перетаскивайте на карту. Для перемещения карты включите «Режим карты» и используйте «+ / −».</div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div style="font-weight:600">Таблица лидеров</div>
          <div class="row">
            <select id="lbDifficulty" class="input">
              <option value="all">Все сложности</option>
              <option value="easy">Лёгкая</option>
              <option value="medium">Средняя</option>
              <option value="hard">Сложная</option>
            </select>
            <input id="lbGroupFilter" class="input" placeholder="Фильтр по группе" style="width:140px">
            <button id="exportCSV" class="btn">Скачать CSV</button>
          </div>
        </div>
        <table class="table" id="leaderboard" style="margin-top:8px">
          <thead><tr><th>#</th><th>ФИО</th><th>Группа</th><th>Сложность</th><th>Время</th><th>Дата</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="footer">Автор: Ситковский Арсений Михайлович, 2025 г. e-mail: omnistat@yandex.ru</div>
</div>

<!-- D3 + TopoJSON (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
(async function(){
  // ====== Firebase init (используем Realtime Database) ======
  const firebaseConfig = {
    apiKey: "AIzaSyCsHMYznP5Li-wNNYjxPRKiWjd1jo5UQ54",
    authDomain: "russian-regions-puzzle.firebaseapp.com",
    projectId: "russian-regions-puzzle",
    storageBucket: "russian-regions-puzzle.firebasestorage.app",
    messagingSenderId: "352890491256",
    appId: "1:352890491256:web:db8388a1fc4810cdcaf88d",
    measurementId: "G-60BX1RW10B",
    databaseURL: "https://russian-regions-puzzle-default-rtdb.firebaseio.com/"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // ====== UI refs ======
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const pick = document.createElement('canvas').getContext('2d');
  const placedEl = document.getElementById('placed');
  const timeEl = document.getElementById('time');
  const statusEl = document.getElementById('status');
  const currentNameEl = document.getElementById('currentName');
  const trayCv = document.getElementById('tray');
  const trayCtx = trayCv.getContext('2d');

  const fioEl = document.getElementById('fio');
  const groupEl = document.getElementById('group');
  const difEl = document.getElementById('difficulty');
  const saveProfileBtn = document.getElementById('saveProfile');

  const lbTable = document.querySelector('#leaderboard tbody');
  const lbDiffEl = document.getElementById('lbDifficulty');
  const lbGroupEl = document.getElementById('lbGroupFilter');
  const exportBtn = document.getElementById('exportCSV');

  const panBtn = document.getElementById('panToggle');
  const zoomInBtn = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');

  // ====== Profile storage ======
  try{
    const saved = JSON.parse(localStorage.getItem('puzzleProfile')||'{}');
    if(saved.fio) fioEl.value = saved.fio;
    if(saved.group) groupEl.value = saved.group;
    if(saved.difficulty) difEl.value = saved.difficulty;
  }catch{}
  saveProfileBtn.onclick = ()=>{
    const prof = { fio: fioEl.value.trim(), group: groupEl.value.trim(), difficulty: difEl.value };
    localStorage.setItem('puzzleProfile', JSON.stringify(prof));
  };

  // ====== Difficulty → snap radius ======
  function snapRadiusBy(diff){
    if(diff==='easy') return 60;     // крупный «магнит»
    if(diff==='medium') return 30;   // средний
    return 12;                       // сложный — почти точное попадание
  }

  // ====== Canvas DPI ======
  let dpr = 1;
  let view = { k: 1, x: 0, y: 0 };
  const viewMin = 0.8, viewMax = 3.5;

  function fitCanvas(){
    const r = cv.getBoundingClientRect();
    dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.max(1, Math.floor(r.width  * dpr));
    const h = Math.max(1, Math.floor((r.height || 540) * dpr));
    cv.width = w; cv.height = h;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    pick.canvas.width = w; pick.canvas.height = h;
    pick.setTransform(dpr,0,0,dpr,0,0);

    // tray canvas DPR
    const tr = trayCv.getBoundingClientRect();
    const tw = Math.max(1, Math.floor(tr.width * dpr)), th = Math.max(1, Math.floor(tr.height * dpr));
    trayCv.width = tw; trayCv.height = th;
    trayCtx.setTransform(dpr,0,0,dpr,0,0);
  }
  fitCanvas(); window.addEventListener('resize', ()=>{ fitCanvas(); drawAll(true); drawTray(); });

  // ====== Load map ======
  const TOPO = 'Russian_regions_TopoJSON.topojson';
  let topo;
  try{
    const res = await fetch(TOPO+'?v='+Date.now(), {cache:'no-store'});
    if(!res.ok) throw new Error('HTTP '+res.status);
    topo = await res.json();
  }catch(e){
    statusEl.textContent = 'Карта не найдена'; statusEl.style.background = '#5b1020';
    console.error(e); return;
  }
  const keys = Object.keys(topo.objects||{});
  const chosen = keys.map(k=>{
    const g=topo.objects[k].geometries||[]; const n=g.length|0;
    const hasPoly=g.some(geom=>/Polygon/i.test(geom.type||'')); const score=(hasPoly?0:1000)+Math.abs(n-89);
    return {k,n,score};
  }).sort((a,b)=>a.score-b.score)[0];
  const geo = topojson.feature(topo, topo.objects[chosen.k]);
  const features = geo.features;

  // ====== Projection (fix date line) ======
  let projection = d3.geoMercator().rotate([-105, 0]);
  let _offset = {x:8,y:8};
  function fitProjection(){
    const w = Math.floor(cv.width/dpr), h = Math.floor(cv.height/dpr);
    const mapW = Math.max(520, Math.floor(w*0.62));
    const mapH = Math.max(280, h-20);
    projection = d3.geoMercator().rotate([-105, 0]);
    projection.fitSize([mapW, mapH], geo);
    _offset = {x:8,y:8};
  }
  fitProjection();
  window.addEventListener('resize', ()=>{ fitProjection(); });

  // ====== Build paths & centroids ======
  function buildPath2D(f){
    const p = new Path2D();
    const geom=f.geometry||{};
    const polys = geom.type==='Polygon' ? [geom.coordinates||[]] : (geom.coordinates||[]);
    polys.forEach(rings=>{
      (rings||[]).forEach(ring=>{
        let prev=null;
        (ring||[]).forEach((lnglat,idx)=>{
          const pt = projection(lnglat); if(!pt) return;
          const x = pt[0]+_offset.x, y = pt[1]+_offset.y;
          if(idx===0){ p.moveTo(x,y); prev=[x,y]; }
          else if(!prev || Math.hypot(x-prev[0], y-prev[1])>0.8){ p.lineTo(x,y); prev=[x,y]; }
        });
        p.closePath();
      });
    });
    return p;
  }
  const paths = features.map(buildPath2D);
  const gp = d3.geoPath(projection);
  const targets = features.map(f=>{ const c=gp.centroid(f); return [c[0]+_offset.x, c[1]+_offset.y]; });

  // ====== Names ======
  const nameKey = (()=>{
    const freq={};
    for(const f of features){
      for(const k in (f.properties||{})){
        const v=f.properties[k];
        if(typeof v==='string' && v.length>=3){
          freq[k]=(freq[k]||0)+(/[\u0400-\u04FF]/.test(v)?2:1);
          if(/name/i.test(k)) freq[k]+=2;
          if(/subj|region|обла|край|респ|город/i.test(k)) freq[k]+=1;
        }
      }
    }
    const arr=Object.entries(freq).sort((a,b)=>b[1]-a[1]);
    return arr.length?arr[0][0]:null;
  })();
  function subjName(i){
    const p = features[i].properties||{};
    return (nameKey && p[nameKey]) ? String(p[nameKey]) : `Субъект №${i+1}`;
  }

  // ====== Game state ======
  const TOTAL = features.length;
  const pieces = features.map((_,i)=>({ i, dx:0, dy:0, locked:false }));
  let order = d3.shuffle(d3.range(TOTAL));
  let cursor = 0;
  let current = order[cursor];
  let startAt=null, finished=false, placed=0;
  placedEl.textContent = `0 / ${TOTAL}`;

  function fmt(ms){ const s=Math.floor(ms/1000),m=Math.floor(s/60),ss=String(s%60).padStart(2,'0'); return `${String(m).padStart(2,'0')}:${ss}` }
  (function tick(){ if(!finished && startAt){ timeEl.textContent = fmt(performance.now()-startAt); } requestAnimationFrame(tick); })();

  // ====== View transforms ======
  function setSceneTransform(c){ c.setTransform(dpr*view.k,0,0,dpr*view.k, dpr*view.x, dpr*view.y); }
  function screenToWorld(x,y){ return { x:(x - view.x)/view.k, y:(y - view.y)/view.k }; }

  // ====== Draw target & pieces ======
  function drawTarget(){
    ctx.save(); setSceneTransform(ctx);
    for(let i=0;i<paths.length;i++){
      ctx.fillStyle = '#10224a'; ctx.globalAlpha = 0.18; ctx.fill(paths[i]);
      ctx.globalAlpha = 1; ctx.strokeStyle = '#25407a'; ctx.lineWidth = (1/view.k);
      ctx.stroke(paths[i]);
    }
    ctx.restore();
  }
  function drawPieces(){
    ctx.save(); setSceneTransform(ctx);
    for(const p of pieces){
      if(!p.locked && p.i !== current) continue; // рисуем только текущую деталь и зафиксированные
      ctx.save(); ctx.translate(p.dx,p.dy);
      ctx.fillStyle = p.locked ? '#00AEEF' : '#7cb8ff';  /* RUDN-blue для зафиксированных */
      ctx.globalAlpha = p.locked ? 0.98 : 0.92;
      ctx.strokeStyle = '#0a2a4f'; ctx.lineWidth = Math.max(0.8/view.k, 0.5);
      ctx.fill(paths[p.i]); ctx.stroke(paths[p.i]);
      ctx.restore();
    }
    ctx.restore();
  }
  function buildPick(){
    const w=Math.floor(cv.width/dpr), h=Math.floor(cv.height/dpr);
    pick.save(); pick.setTransform(dpr*view.k,0,0,dpr*view.k, dpr*view.x, dpr*view.y);
    pick.clearRect(0,0,w,h);
    const p = pieces[current];
    pick.save(); pick.translate(p.dx,p.dy);
    pick.fillStyle='rgb(10,10,1)'; pick.strokeStyle=pick.fillStyle;
    pick.fill(paths[p.i]); pick.stroke(paths[p.i]);
    pick.restore(); pick.restore();
  }
  function drawAll(rebuild=false){
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,cv.width,cv.height);
    drawTarget(); drawPieces();
    if(rebuild) buildPick();
  }

  // ====== Tray preview (fixed) ======
  function drawTray(){
    trayCtx.setTransform(dpr,0,0,dpr,0,0);
    trayCtx.clearRect(0,0,trayCv.width,trayCv.height);
    // рамка и фон
    trayCtx.fillStyle='#0b132b'; trayCtx.fillRect(0,0,trayCv.width/dpr,trayCv.height/dpr);
    // вписываем текущий path в прямоугольник с полями
    const i = current, path = paths[i];
    // оценим bbox через временный канвас
    const tmp = document.createElement('canvas').getContext('2d');
    const W = Math.floor(trayCv.width/dpr), H=Math.floor(trayCv.height/dpr);
    tmp.canvas.width = trayCv.width; tmp.canvas.height = trayCv.height;
    tmp.setTransform(dpr,0,0,dpr,0,0);
    tmp.clearRect(0,0,W,H);
    tmp.fillStyle='#fff'; tmp.fill(path);
    const data = tmp.getImageData(0,0,W,H).data;
    let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
    for(let y=0;y<H;y+=2){
      for(let x=0;x<W;x+=2){
        const a=data[(y*W+x)*4+3]; if(a>0){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }
      }
    }
    if(minX===1e9) return;
    const bw=maxX-minX, bh=maxY-minY;
    const pad=12, boxW=W-2*pad, boxH=H-2*pad;
    const s = Math.min(boxW/bw, boxH/bh)*0.9;
    const cx = pad + boxW/2, cy = pad + boxH/2;
    const offx = (minX + bw/2), offy=(minY+bh/2);

    trayCtx.save();
    trayCtx.translate(cx,cy);
    trayCtx.scale(s,s);
    trayCtx.translate(-offx, -offy);
    trayCtx.fillStyle = '#7cb8ff';
    trayCtx.strokeStyle = '#0a2a4f';
    trayCtx.globalAlpha = 0.95;
    trayCtx.lineWidth = 1/s;
    trayCtx.fill(path);
    trayCtx.stroke(path);
    trayCtx.restore();

    currentNameEl.textContent = subjName(i);
  }

  document.getElementById('takePiece').onclick = ()=>{
    // поместим деталь под центр карты
    const rect = cv.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    const w = screenToWorld(cx,cy);
    const p = pieces[current];
    const [tx,ty] = targets[p.i];
    p.dx = w.x - tx; p.dy = w.y - ty;
    drawAll(true);
  };
  trayCv.addEventListener('pointerdown', ()=> document.getElementById('takePiece').click());

  // ====== Drag / Pan / Zoom ======
  let panMode=false, panStart=null, dragPiece=null, dragOff={x:0,y:0};
  panBtn.onclick = ()=>{ panMode=!panMode; panBtn.textContent = `Режим карты: ${panMode?'вкл':'выкл'}`; };

  function pickAt(x,y){
    const px=Math.max(0,Math.min(cv.width-1,Math.round(x*dpr)));
    const py=Math.max(0,Math.min(cv.height-1,Math.round(y*dpr)));
    const d=pick.getImageData(px,py,1,1).data;
    return (d[3]>0)? pieces[current] : null;
  }

  function onDown(e){
    const r=cv.getBoundingClientRect(), x=e.clientX-r.left, y=e.clientY-r.top;
    if(panMode){ panStart={x,y, vx:view.x, vy:view.y}; return; }
    const p = pickAt(x,y);
    if(!p || p.locked) return;
    dragPiece=p; const [cx,cy]=targets[p.i];
    const s=screenToWorld(x,y); dragOff={x: s.x-(cx+p.dx), y: s.y-(cy+p.dy)};
  }
  function onMove(e){
    const r=cv.getBoundingClientRect(), x=e.clientX-r.left, y=e.clientY-r.top;
    if(panMode && panStart){ view.x = panStart.vx + (x - panStart.x); view.y = panStart.vy + (y - panStart.y); drawAll(true); return; }
    if(!dragPiece) return;
    const [cx,cy]=targets[dragPiece.i]; const s=screenToWorld(x,y);
    dragPiece.dx = (s.x - dragOff.x) - cx;
    dragPiece.dy = (s.y - dragOff.y) - cy;
    drawAll(false);
  }
  function onUp(e){
    if(panMode){ panStart=null; return; }
    if(!dragPiece) return;
    // Новый критерий: расстояние от центроида детали до целевого центроида
    const r = snapRadiusBy(difEl.value);
    const d = Math.hypot(dragPiece.dx, dragPiece.dy);
    if(d < r){
      dragPiece.dx=0; dragPiece.dy=0;
      if(!dragPiece.locked){
        dragPiece.locked=true;
        placed++; placedEl.textContent = `${placed} / ${TOTAL}`;
        if(placed===1 && !startAt) startAt = performance.now();
        if(placed>=TOTAL && !finished){
          finished=true;
          statusEl.textContent = 'Готово! ' + timeEl.textContent; statusEl.style.background = '#0a3b2f';
          persistResult();
        }else{
          // следующий субъект
          do { cursor++; } while(cursor<TOTAL && pieces[order[cursor]]?.locked);
          if(cursor<TOTAL) { current=order[cursor]; drawTray(); }
        }
      }
    }
    dragPiece=null; drawAll(true);
  }
  cv.addEventListener('pointerdown', e=>{ cv.setPointerCapture(e.pointerId); onDown(e); });
  cv.addEventListener('pointermove', onMove);
  cv.addEventListener('pointerup',   e=>{ onUp(e); try{cv.releasePointerCapture(e.pointerId);}catch{} });
  cv.addEventListener('pointercancel', ()=>{ dragPiece=null; panStart=null; });

  function zoomAt(factor, cx, cy){
    const old=view.k, k=Math.max(viewMin, Math.min(viewMax, old*factor)), f=k/old;
    const r=cv.getBoundingClientRect(), x=cx, y=cy;
    const w=screenToWorld(x,y);
    view.k=k; view.x=x - w.x*k; view.y=y - w.y*k; drawAll(true);
  }
  zoomInBtn.onclick = ()=>{ const r=cv.getBoundingClientRect(); zoomAt(1.2, r.width/2, r.height/2); };
  zoomOutBtn.onclick= ()=>{ const r=cv.getBoundingClientRect(); zoomAt(1/1.2, r.width/2, r.height/2); };
  cv.addEventListener('wheel', (e)=>{ e.preventDefault(); const r=cv.getBoundingClientRect(); zoomAt(e.deltaY<0?1.15:1/1.15, e.clientX-r.left, e.clientY-r.top); }, {passive:false});

  // ====== Reset / Shuffle / Help ======
  document.getElementById('reset').onclick = ()=>{
    placed=0; placedEl.textContent=`0 / ${TOTAL}`; startAt=null; finished=false; timeEl.textContent='00:00';
    pieces.forEach(p=>{ p.locked=false; p.dx=0; p.dy=0; });
    order=d3.shuffle(d3.range(TOTAL)); cursor=0; current=order[cursor];
    view={k:1,x:0,y:0}; fitProjection(); drawTray(); drawAll(true);
  };
  document.getElementById('help').onclick = ()=>{
    alert('Правила:\n• Укажите ФИО и номер группы. Выберите сложность.\n• Нажмите «Взять деталь» в лотке справа и перетащите на карту.\n• Включите «Режим карты», чтобы двигать/масштабировать карту; выключите — чтобы снова перетаскивать деталь.\n• Поставленные субъекты подсвечиваются ярко-сине-голубым. По одному субъекту за раз.\n• По завершении результат сохраняется в таблицу лидеров.');
  };

  // ====== Start ======
  statusEl.textContent='Карта загружена';
  drawTray(); drawAll(true);

  // ====== Leaderboard (Firebase Realtime DB) ======
  function msToMMSS(ms){ const s=Math.floor(ms/1000), m=Math.floor(s/60), ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }
  function renderLeaderboard(all){
    const diff = lbDiffEl.value, gflt = lbGroupEl.value.trim().toLowerCase();
    // Берём лучшие времена по каждому ФИО в рамках выбранной сложности/фильтра
    const byFio = new Map();
    for(const r of all){
      if(diff!=='all' && r.difficulty!==diff) continue;
      if(gflt && (!r.group || String(r.group).toLowerCase().indexOf(gflt)===-1)) continue;
      const key = (r.fio||'').trim() || '(без ФИО)';
      const prev = byFio.get(key);
      if(!prev || (r.time_ms||1e12) < (prev.time_ms||1e12)) byFio.set(key, r);
    }
    const rows = Array.from(byFio.values()).sort((a,b)=> (a.time_ms||1e12)-(b.time_ms||1e12)).slice(0,50);
    lbTable.innerHTML = rows.map((r,i)=>`<tr><td>${i+1}</td><td>${(r.fio||'')}</td><td>${(r.group||'')}</td><td>${labelDifficulty(r.difficulty)}</td><td>${msToMMSS(r.time_ms||0)}</td><td>${new Date(r.timestamp||Date.now()).toLocaleString()}</td></tr>`).join('');
    // CSV экспорта
    exportBtn.onclick = ()=>{
      const hdr = ['rank','fio','group','difficulty','time_mmss','time_ms','timestamp'];
      const lines = [hdr.join(',')].concat(rows.map((r,i)=>[
        i+1, q(r.fio), q(r.group), r.difficulty, msToMMSS(r.time_ms||0), r.time_ms||0, new Date(r.timestamp||Date.now()).toISOString()
      ].join(',')));
      const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8;'});
      const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='puzzle_results.csv'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
    };
  }
  function q(s){ s=String(s||''); return `"${s.replace(/"/g,'""')}"`; }
  function labelDifficulty(d){ return d==='easy'?'Лёгкая':(d==='medium'?'Средняя':'Сложная'); }

  // Подписка на БД
  const resultsRef = db.ref('results');
  resultsRef.on('value', snap=>{
    const val = snap.val()||{};
    const all = Object.keys(val).map(k=>val[k]).filter(Boolean);
    renderLeaderboard(all);
  });
  lbDiffEl.onchange = ()=> resultsRef.once('value', s=> renderLeaderboard(Object.values(s.val()||{})));
  lbGroupEl.oninput = ()=> resultsRef.once('value', s=> renderLeaderboard(Object.values(s.val()||{})));

  // ====== Persist result to Firebase ======
  function persistResult(){
    const fio = fioEl.value.trim();
    const group = groupEl.value.trim();
    const difficulty = difEl.value;
    const time_ms = Math.floor((performance.now() - startAt) || 0);
    const payload = {
      fio, group, difficulty, time_ms,
      placed: placed, total: TOTAL,
      timestamp: Date.now(),
      user_agent: navigator.userAgent || ''
    };
    db.ref('results').push(payload).catch(err=>console.error('DB write error:', err));
  }

  // ====== Start first current piece ======
  current = order[cursor]; drawTray(); drawAll(true);
})();
</script>
</body>
</html>
