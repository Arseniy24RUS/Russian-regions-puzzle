<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Онлайн-пазл «Карта субъектов Российской Федерации» — Canvas, лидеры, Firebase</title>
<style>
  :root{ --bg:#0d1427; --panel:#111a2e; --muted:#a9b7d6; }
  html,body{height:100%;margin:0;background:var(--bg);color:#e7eeff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  *{ box-sizing:border-box; user-select:none; -webkit-user-select:none; -webkit-tap-highlight-color:transparent }
  .wrap{ max-width:1200px; margin:0 auto; padding:10px }
  .card{ background:var(--panel); border:1px solid #1d2745; border-radius:14px; padding:12px; box-shadow:0 8px 20px rgba(0,0,0,.25) }
  h1{ font-size:18px; margin:0 0 8px }
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .pill{ display:inline-flex; align-items:center; gap:6px; background:#0f1733; border:1px solid #223062; border-radius:999px; padding:6px 10px; font-size:12px; color:#cfe0ff }
  .btn{ background:#0f1733; border:1px solid #223062; color:#e7eeff; padding:8px 12px; border-radius:10px; cursor:pointer }
  .input{ background:#0f1733; border:1px solid #223062; color:#e7eeff; padding:8px 10px; border-radius:10px }
  select.input{ padding-right:28px }
  .grid{ display:grid; grid-template-columns:1fr; gap:10px }
  canvas#cv{ width:100%; height:72vh; min-height:520px; background:#0a1127; border:1px solid #1d2747; border-radius:12px; display:block; touch-action:none }
  .table{ width:100%; border-collapse:collapse; font-size:13px }
  .table th,.table td{ border-bottom:1px solid #1d2745; padding:6px 8px; text-align:left }
  .footer{ margin-top:12px; font-size:12px; color:#a9b7d6; text-align:center }
</style>
</head>
<body>
<div class="wrap">

  <div class="card">
    <h1>Онлайн-пазл «Карта субъектов Российской Федерации»</h1>
    <div class="row">
      <label>ФИО: <input id="fio" class="input" style="width:260px" placeholder="Иванов Иван Иванович"></label>
      <label>Номер группы: <input id="group" class="input" style="width:160px" placeholder="ГГУБД-01-25"></label>
      <label>Сложность:
        <select id="difficulty" class="input">
          <option value="easy">Лёгкая</option>
          <option value="medium">Средняя</option>
          <option value="hard">Высокая</option>
        </select>
      </label>
      <span class="pill">Поставлено: <b id="placed">0 / 89</b></span>
      <span class="pill">Время: <b id="time">00:00</b></span>
      <button id="reset" class="btn">Сбросить</button>
      <button id="help" class="btn">Инструкция</button>
      <span style="flex:1"></span>
      <button id="returnPiece" class="btn">Вернуть деталь</button>
      <button id="centerView" class="btn">Центрировать карту</button>
      <button id="zoomOut" class="btn">−</button>
      <button id="zoomIn" class="btn">+</button>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <canvas id="cv" width="1000" height="680"></canvas>
      <span id="status" class="pill" style="margin-top:6px; display:inline-block">Загрузка карты…</span>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="row" style="gap:12px">
          <div style="font-weight:600">Таблица лидеров</div>
          <div class="pill">Лучший результат в пределах своей сложности</div>
        </div>
        <div class="row">
          <input id="lbGroupFilter" class="input" placeholder="Фильтр по группе" style="width:180px">
          <button id="exportCSV" class="btn">Скачать CSV (все результаты)</button>
        </div>
      </div>

      <div style="font-weight:600; margin-top:10px">Лёгкая</div>
      <table class="table" id="leader_easy" style="margin-top:6px">
        <thead><tr><th>#</th><th>ФИО</th><th>Группа</th><th>Время</th><th>Дата</th></tr></thead>
        <tbody></tbody>
      </table>

      <div style="font-weight:600; margin-top:10px">Средняя</div>
      <table class="table" id="leader_medium" style="margin-top:6px">
        <thead><tr><th>#</th><th>ФИО</th><th>Группа</th><th>Время</th><th>Дата</th></tr></thead>
        <tbody></tbody>
      </table>

      <div style="font-weight:600; margin-top:10px">Высокая</div>
      <table class="table" id="leader_hard" style="margin-top:6px">
        <thead><tr><th>#</th><th>ФИО</th><th>Группа</th><th>Время</th><th>Дата</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="footer">Автор: Ситковский Арсений Михайлович, 2025 г. e-mail: omnistat@yandex.ru</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
(async function(){
  // ===== Firebase =====
  const firebaseConfig = {
    apiKey: "AIzaSyCsHMYznP5Li-wNNYjxPRKiWjd1jo5UQ54",
    authDomain: "russian-regions-puzzle.firebaseapp.com",
    projectId: "russian-regions-puzzle",
    storageBucket: "russian-regions-puzzle.firebasestorage.app",
    messagingSenderId: "352890491256",
    appId: "1:352890491256:web:db8388a1fc4810cdcaf88d",
    measurementId: "G-60BX1RW10B",
    databaseURL: "https://russian-regions-puzzle-default-rtdb.firebaseio.com/"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // ===== UI refs (как в стабильной версии) =====
  const cv = document.getElementById('cv'); const ctx = cv.getContext('2d');
  const pick = document.createElement('canvas').getContext('2d');
  const statusEl = document.getElementById('status');
  const placedEl = document.getElementById('placed');
  const timeEl = document.getElementById('time');
  const fioEl = document.getElementById('fio');
  const groupEl = document.getElementById('group');
  const difEl = document.getElementById('difficulty');

  // Лидеры: три отдельных tbody + фильтр по группе и экспорт
  const tbEasy   = document.querySelector('#leader_easy tbody');
  const tbMedium = document.querySelector('#leader_medium tbody');
  const tbHard   = document.querySelector('#leader_hard tbody');
  const lbGroupEl = document.getElementById('lbGroupFilter');
  const exportBtn = document.getElementById('exportCSV');

  const zoomInBtn = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');
  const helpBtn = document.getElementById('help');
  const returnBtn = document.getElementById('returnPiece');
  const centerBtn = document.getElementById('centerView');

  // ===== DPI / Canvas =====
  let dpr = 1;
  function fitCanvas(){
    const r = cv.getBoundingClientRect();
    dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.max(1, Math.floor(r.width  * dpr));
    const h = Math.max(1, Math.floor((r.height || 540) * dpr));
    cv.width = w; cv.height = h;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    pick.canvas.width = w; pick.canvas.height = h;
    pick.setTransform(dpr,0,0,dpr,0,0);
  }
  fitCanvas();
  window.addEventListener('resize', ()=>{
    fitCanvas(); fitProjection(); rebuildGeometry(); fitView();
    if(!pieces[current].locked){ setPieceInTray(current, true); buildPick(); }
    drawAll(true);
  });

  // ===== Load TopoJSON =====
  const TOPO = 'Russian_regions_TopoJSON.topojson';
  let topo;
  try{
    const res = await fetch(TOPO+'?v='+Date.now(), {cache:'no-store'});
    if(!res.ok) throw new Error('HTTP '+res.status);
    topo = await res.json();
  }catch(e){
    statusEl.textContent = 'Карта не найдена'; statusEl.style.background = '#5b1020';
    console.error(e); return;
  }
  const chosen = Object.keys(topo.objects||{}).map(k=>{
    const g=topo.objects[k].geometries||[]; const n=g.length|0;
    const hasPoly=g.some(geom=>/Polygon/i.test(geom.type||'')); const score=(hasPoly?0:1000)+Math.abs(n-89);
    return {k,n,score};
  }).sort((a,b)=>a.score-b.score)[0].k;

  const geo = topojson.feature(topo, topo.objects[chosen]);
  const features = geo.features;

  // ===== Projection =====
  let projection = d3.geoMercator().rotate([-105,0]);
  let _pad = 10;
  function fitProjection(){
    const w = Math.floor(cv.width / dpr), h = Math.floor(cv.height/ dpr);
    projection = d3.geoMercator().rotate([-105,0]).fitSize([w-2*_pad, h-2*_pad], geo);
  }
  fitProjection();

  // ===== Helpers =====
  function projectPt(lnglat){
    const pt = projection(lnglat);
    return pt ? [pt[0]+_pad, pt[1]+_pad] : null;
  }
  function featureBoundsPx(f){
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    const g=f.geometry||{}, arr=(g.type==='Polygon')?[g.coordinates||[]]:(g.coordinates||[]);
    arr.forEach(rings=>{
      (rings||[]).forEach(ring=>{
        (ring||[]).forEach(ll=>{
          const p=projectPt(ll); if(!p) return;
          const x=p[0], y=p[1];
          if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y;
        });
      });
    });
    if(!isFinite(minX)){ minX=0;minY=0;maxX=1;maxY=1; }
    return {minX,minY,maxX,maxY, w:Math.max(1,maxX-minX), h:Math.max(1,maxY-minY), cx:(minX+maxX)/2, cy:(minY+maxY)/2};
  }

  // ===== Geometry build (как было) =====
  function buildPath2D(f, tol, seamBreak){
    const p = new Path2D();
    const g=f.geometry||{}, arr=(g.type==='Polygon')?[g.coordinates||[]]:(g.coordinates||[]);
    arr.forEach(rings=>{
      (rings||[]).forEach(ring=>{
        let prev=null, subStart=null;
        (ring||[]).forEach((lnglat,idx)=>{
          const pt = projectPt(lnglat); if(!pt) return;
          const x = pt[0], y = pt[1];
          if(!prev){ p.moveTo(x,y); prev=[x,y]; subStart=[x,y]; return; }
          const d = Math.hypot(x-prev[0], y-prev[1]);
          if(d > (seamBreak||80)){ if(subStart) p.closePath(); p.moveTo(x,y); subStart=[x,y]; prev=[x,y]; }
          else if(d > (tol||0)){ p.lineTo(x,y); prev=[x,y]; }
        });
        if(subStart) p.closePath();
      });
    });
    return p;
  }

  let paths   = features.map(f=>buildPath2D(f, 0.8, 80));
  let pathsHi = new Array(features.length);
  function getHiPath(i){ return pathsHi[i] || (pathsHi[i]=buildPath2D(features[i], 0, 80)); }

  let boundsArr = features.map(featureBoundsPx);
  let anchors   = boundsArr.map(b=>[b.cx,b.cy]);

  function rebuildGeometry(){
    paths   = features.map(f=>buildPath2D(f, 0.8, 80));
    pathsHi = new Array(features.length);
    boundsArr = features.map(featureBoundsPx);
    anchors   = boundsArr.map(b=>[b.cx,b.cy]);
  }

  // ===== View & tray =====
  const TRAY = { height:118, margin:8, pad:8 };
  let view = { k:1, x:0, y:0 };
  const viewMin = 0.8, viewMax = 16.0;

  function worldBounds(){
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    boundsArr.forEach(b=>{ if(b.minX<minX)minX=b.minX; if(b.minY<minY)minY=b.minY; if(b.maxX>maxX)maxX=b.maxX; if(b.maxY>maxY)maxY=b.maxY; });
    return {minX,minY,maxX,maxY};
  }
  function fitView(){
    const r = cv.getBoundingClientRect();
    const W = r.width, H = r.height;
    const b = worldBounds();
    const w = Math.max(1, b.maxX - b.minX), h = Math.max(1, b.maxY - b.minY);
    const pad = 8;
    const mapBottom = H - TRAY.height - TRAY.margin;
    const availH = (mapBottom - pad) - (pad);
    const k = Math.min((W - 2*pad)/w, (availH)/h);
    view.k = k;
    const cx = (b.minX + b.maxX)/2;
    view.x = W/2 - k*cx;
    view.y = (mapBottom - pad) - k*b.maxY;
  }
  fitView();

  function setScene(c){ c.setTransform(dpr*view.k,0,0,dpr*view.k, dpr*view.x, dpr*view.y); }
  function screenToWorld(x,y){ return { x:(x - view.x)/view.k, y:(y - view.y)/view.k }; }

  // ===== Names =====
  const nameKey = (()=>{ const freq={}; for(const f of features){ for(const k in (f.properties||{})){ const v=f.properties[k]; if(typeof v==='string' && v.length>=3){ freq[k]=(freq[k]||0)+(/[\u0400-\u04FF]/.test(v)?2:1); if(/name/i.test(k)) freq[k]+=2; if(/subj|region|обла|край|респ|город/i.test(k)) freq[k]+=1; } } } const arr=Object.entries(freq).sort((a,b)=>b[1]-a[1]); return arr.length?arr[0][0]:null; })();
  function getName(i){ const p=features[i].properties||{}; return (nameKey&&p[nameKey])?String(p[nameKey]):`Субъект РФ №${i+1}`; }

  // ===== Game state =====
  const TOTAL = features.length;
  const pieces = features.map((_,i)=>({ i, dx:0, dy:0, locked:false, inTray:true }));
  let order = d3.shuffle(d3.range(TOTAL));
  let cursor = 0;
  let current = order[cursor];
  let placed = 0; placedEl.textContent=`0 / ${TOTAL}`;
  let startAt=null, finished=false;
  let difficultyLocked=false;

  // ===== Tray placement =====
  function trayRect(){ const r=cv.getBoundingClientRect(); return { x: TRAY.pad, y: r.height - TRAY.height - TRAY.margin, w: r.width - 2*TRAY.pad, h: TRAY.height }; }
  function trayCenter(){ const tr=trayRect(); return { x: tr.x + tr.w*0.5, y: tr.y + tr.h*0.5 }; }
  function spawnOffsetsFor(i){ const c=trayCenter(); const w=screenToWorld(c.x,c.y); const [ax,ay]=anchors[i]; return { dx:w.x-ax, dy:w.y-ay }; }
  function setPieceInTray(i, yes){
    const p = pieces[i];
    p.inTray = !!yes;
    if(p.inTray){ const off = spawnOffsetsFor(i); p.dx = off.dx; p.dy = off.dy; }
  }
  function setCurrent(i){
    current = i;
    setPieceInTray(i, true);
    buildPick(); drawAll(false);
  }

  // ===== Finish recolor =====
  let recolorProgress = 0;
  const BLUE = [0x00,0xAE,0xEF];
  const RED  = [0xFF,0x3B,0x30];
  function mix(a,b,t){ return Math.round(a+(b-a)*t); }
  function rgbaHex(arr){ return `rgb(${arr[0]},${arr[1]},${arr[2]})`; }
  function pieceFillColor(){
    if(recolorProgress<=0) return rgbaHex(BLUE);
    const c=[ mix(BLUE[0],RED[0],recolorProgress), mix(BLUE[1],RED[1],recolorProgress), mix(BLUE[2],RED[2],recolorProgress) ];
    return rgbaHex(c);
  }
  function startRecolor(){
    const t0 = performance.now();
    function step(now){
      recolorProgress = Math.min(1, (now - t0)/1000);
      drawAll(false);
      if(recolorProgress<1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  // ===== Render =====
  function drawMap(){
    ctx.save(); setScene(ctx);
    for(const path of paths){ ctx.fillStyle='#152b55'; ctx.fill(path); }
    ctx.strokeStyle='#25407a';
    ctx.lineWidth=Math.max(1/view.k, 0.6);
    for(const path of paths){ ctx.stroke(path); }
    ctx.restore();
  }

  function drawPieces(){
    ctx.save(); setScene(ctx);
    for(const p of pieces){
      if(!p.locked) continue;
      ctx.save(); ctx.translate(p.dx,p.dy);
      ctx.fillStyle = pieceFillColor();
      ctx.globalAlpha=0.98;
      ctx.strokeStyle='#08305c'; ctx.lineWidth=Math.max(1/view.k, 0.6);
      ctx.fill(paths[p.i]); ctx.stroke(paths[p.i]);
      ctx.restore();
    }
    ctx.restore();

    const pc = pieces[current];
    if(!pc.locked){
      if(pc.inTray){
        const tr = trayRect();
        const b = boundsArr[pc.i];
        const bw = b.w, bh = b.h;
        const s = Math.min((tr.w*0.8)/bw, (tr.h*0.8)/bh);
        const cx = tr.x + tr.w/2, cy = tr.y + tr.h/2;
        const hiPath = getHiPath(pc.i);

        ctx.save();
        ctx.setTransform(dpr,0,0,dpr,0,0);
        ctx.translate(cx, cy);
        ctx.scale(s, s);
        ctx.translate(-b.cx, -b.cy);

        ctx.fillStyle='#FF3B30'; ctx.globalAlpha=0.98;
        ctx.fill(hiPath);

        const fixedPx = 1.2;
        ctx.strokeStyle='#680000';
        ctx.lineWidth = fixedPx / s;
        ctx.stroke(hiPath);
        ctx.restore();
      }else{
        ctx.save(); setScene(ctx);
        ctx.translate(pc.dx,pc.dy);
        ctx.fillStyle='#FF3B30'; ctx.globalAlpha=0.98;
        ctx.strokeStyle='#680000'; ctx.lineWidth=Math.max(1/view.k,0.6);
        ctx.fill(paths[pc.i]); ctx.stroke(paths[pc.i]);
        ctx.restore();
      }
    }
  }

  function drawTray(){
    const tr = trayRect();
    ctx.save(); ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.strokeStyle='rgba(200,220,255,.35)'; ctx.setLineDash([8,6]); ctx.lineWidth=1.5;
    ctx.strokeRect(tr.x,tr.y,tr.w,tr.h); ctx.setLineDash([]);
    ctx.fillStyle='#cfe0ff';
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Текущий субъект РФ:', tr.x+10, tr.y+18);
    ctx.font='bold 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(finished ? 'Готово!' : getName(current), tr.x+10, tr.y+38);
    ctx.restore();
  }

  function buildPick(){
    pick.save();
    pick.setTransform(dpr*view.k,0,0,dpr*view.k, dpr*view.x, dpr*view.y);
    pick.clearRect(0,0,cv.width,cv.height);
    const p = pieces[current];
    if(!p.locked && !p.inTray){
      pick.save(); pick.translate(p.dx,p.dy);
      pick.fillStyle='rgb(10,10,1)'; pick.strokeStyle=pick.fillStyle;
      pick.fill(paths[p.i]); pick.stroke(paths[p.i]);
      pick.restore();
    }
    pick.restore();
  }

  function drawAll(rebuild=false){
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,cv.width,cv.height);
    drawMap(); drawPieces(); drawTray();
    if(rebuild) buildPick();
  }

  // ===== Fireworks + фанфары (как было) =====
  let celebrating = false;
  function playFanfare(){ try{ const AC = new (window.AudioContext||window.webkitAudioContext)(); const seq = [880, 1175, 1568]; let t = AC.currentTime + 0.05; seq.forEach(f=>{ const o=AC.createOscillator(), g=AC.createGain(); o.type='triangle'; o.frequency.value=f; g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.2,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.25); o.connect(g).connect(AC.destination); o.start(t); o.stop(t+0.26); t+=0.19; }); }catch(e){} }
  function startFireworks(){
    celebrating = true;
    const t0 = performance.now();
    const r = cv.getBoundingClientRect();
    const W = r.width, H = r.height;
    const mapBottom = H - TRAY.height - TRAY.margin;
    const bursts = [];
    function newBurst(){ const x = 40 + Math.random()*(W-80); const y = 40 + Math.random()*(mapBottom-80); const c = 24 + Math.floor(Math.random()*24); const parts=[]; for(let i=0;i<c;i++){ const ang=(i/c)*Math.PI*2; const spd = 1.2 + Math.random()*2.2; parts.push({x,y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, life:1}); } bursts.push({parts, age:0}); }
    function step(now){
      const dt = Math.min(0.033, (now - (step._last||now))/1000); step._last = now;
      const elapsed = now - t0;
      if(elapsed < 1600 && (!step._lastBurst || now - step._lastBurst > 180)){ newBurst(); step._lastBurst = now; }
      drawAll(false);
      ctx.save(); ctx.setTransform(dpr,0,0,dpr,0,0);
      bursts.forEach(b=>{
        b.age += dt;
        b.parts.forEach(p=>{
          p.vy += 0.06;
          p.x += p.vx*4; p.y += p.vy*4;
          p.life -= 0.015 + Math.random()*0.01;
          const a = Math.max(0, Math.min(1, p.life));
          ctx.globalAlpha = a;
          ctx.fillStyle = 'rgb('+(200+Math.floor(Math.random()*55))+','+(150+Math.floor(Math.random()*105))+',255)';
          ctx.beginPath(); ctx.arc(p.x,p.y, 2.2, 0, Math.PI*2); ctx.fill();
        });
      });
      for(let i=bursts.length-1;i>=0;i--){ bursts[i].parts = bursts[i].parts.filter(p=>p.life>0); if(!bursts[i].parts.length) bursts.splice(i,1); }
      ctx.restore();
      if(elapsed < 2300 || bursts.length){ requestAnimationFrame(step); } else { celebrating=false; }
    }
    requestAnimationFrame(step);
    playFanfare();
  }

  // ===== Таймер =====
  function fmt(ms){ const CAP=(59*60+59)*1000; const t=Math.min(ms,CAP); const s=Math.floor(t/1000), m=Math.floor(s/60), ss=String(s%60).padStart(2,'0'); return `${String(m).padStart(2,'0')}:${ss}` }
  (function tick(){ if(!finished && startAt){ timeEl.textContent = fmt(performance.now()-startAt); } requestAnimationFrame(tick); })();

  // ===== Difficulty & locking =====
  function snapRadiusBy(diff){ return diff==='easy'?60:(diff==='medium'?30:12); }
  difEl.addEventListener('change',()=>{ saveProfile(); if(difficultyLocked){ alert('Сложность нельзя менять после установки первой детали. Нажмите «Сбросить» для новой игры.'); } });

  // ===== Input: drag / pan / zoom + pinch =====
  let draggingPiece=false, draggingFromTray=false, draggingPan=false, dragOff={x:0,y:0}, panOff={x:0,y:0};
  const pointers=new Map(); let pinch=null;

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function zoomAt(factor, cx, cy){
    const old=view.k, k=Math.max(viewMin, Math.min(viewMax, old*factor));
    const w=screenToWorld(cx,cy);
    view.k=k; view.x = cx - w.x*k; view.y = cy - w.y*k; drawAll(true);
  }
  function startPinch(){
    const pts=[...pointers.values()]; if(pts.length<2) return;
    const a=pts[0], b=pts[1]; const cx=(a.x+b.x)/2, cy=(a.y+b.y)/2;
    pinch = { cx, cy, d0: dist(a,b), k0:view.k, world: screenToWorld(cx,cy) };
  }
  function updatePinch(){
    if(!pinch) return;
    const pts=[...pointers.values()]; if(pts.length<2) return;
    const a=pts[0], b=pts[1]; const d1=dist(a,b); if(d1<=0) return;
    const factor=d1/pinch.d0; const k=Math.max(viewMin, Math.min(viewMax, pinch.k0*factor));
    const w=pinch.world; view.k=k; view.x = pinch.cx - w.x*k; view.y = pinch.cy - w.y*k; drawAll(true);
  }

  function inTray(x,y){ const tr=trayRect(); return x>=tr.x && x<=tr.x+tr.w && y>=tr.y && y<=tr.y+tr.h; }

  cv.addEventListener('pointerdown', e=>{
    cv.setPointerCapture(e.pointerId);
    const r=cv.getBoundingClientRect(), x=e.clientX-r.left, y=e.clientY-r.top;
    pointers.set(e.pointerId,{x,y});
    if(pointers.size===2){ draggingPiece=false; draggingPan=false; startPinch(); drawAll(true); return; }

    const p = pieces[current];
    if(!p.locked && inTray(x,y)){
      draggingPiece=true; draggingFromTray=true;
    }else{
      const px=Math.max(0,Math.min(cv.width-1,Math.round(x*dpr))), py=Math.max(0,Math.min(cv.height-1,Math.round(y*dpr)));
      const d=pick.getImageData(px,py,1,1).data; const onPiece = (d[3]>0);
      if(onPiece){ draggingPiece=true; draggingFromTray=false;
        const s=screenToWorld(x,y); const [ax,ay]=anchors[current];
        dragOff={x: s.x-(ax+p.dx), y: s.y-(ay+p.dy)};
      }else{
        draggingPan=true; panOff={x:x - view.x, y:y - view.y};
      }
    }
  });

  cv.addEventListener('pointermove', e=>{
    const r=cv.getBoundingClientRect(), x=e.clientX-r.left, y=e.clientY-r.top;
    if(pointers.has(e.pointerId)) pointers.set(e.pointerId,{x,y});
    if(pointers.size>=2){ updatePinch(); return; }

    const p=pieces[current];
    if(draggingPiece){
      if(draggingFromTray){
        const tr=trayRect();
        if(y < tr.y){
          const s=screenToWorld(x,y); const [ax,ay]=anchors[current];
          p.inTray=false; p.dx = s.x - ax; p.dy = s.y - ay;
          dragOff={x:0,y:0};
          buildPick();
        }
      }else{
        const s=screenToWorld(x,y); const [ax,ay]=anchors[current];
        p.dx = s.x - ax - dragOff.x; p.dy = s.y - ay - dragOff.y;
      }
      drawAll(false);
    }else if(draggingPan){
      view.x = x - panOff.x; view.y = y - panOff.y; drawAll(true);
    }
  });

  function endPointer(e){
    if(pointers.has(e.pointerId)) pointers.delete(e.pointerId);
    if(pointers.size<2) pinch=null;

    if(draggingPiece){
      const p=pieces[current];
      if(!p.inTray){
        const remaining = TOTAL - placed;
        const distSnap=Math.hypot(p.dx,p.dy);
        const mustAutoSnap = (remaining === 1);
        if(mustAutoSnap || distSnap < snapRadiusBy(difEl.value)){
          p.dx=0; p.dy=0;
          if(!p.locked){
            p.locked=true; placed++; placedEl.textContent=`${placed} / ${TOTAL}`;
            if(!startAt) startAt=performance.now();
            if(!difficultyLocked){ difEl.disabled=true; difficultyLocked=true; }
            if(placed>=TOTAL && !finished){
              finished=true;
              statusEl.textContent='Готово! '+timeEl.textContent; statusEl.style.background='#0a3b2f';
              persistResult();
              if(!celebrating) startFireworks();
              startRecolor();
            }else{
              do{ cursor++; }while(cursor<TOTAL && pieces[order[cursor]]?.locked);
              if(cursor<TOTAL){ setCurrent(order[cursor]); }
            }
          }
        }
      }
      drawAll(true);
    }
    draggingPiece=false; draggingFromTray=false; draggingPan=false;
    try{cv.releasePointerCapture(e.pointerId);}catch{}
  }
  cv.addEventListener('pointerup', endPointer);
  cv.addEventListener('pointercancel', endPointer);

  cv.addEventListener('wheel', (e)=>{ e.preventDefault(); const r=cv.getBoundingClientRect(); const k=(e.deltaY<0)?1.15:(1/1.15); zoomAt(k, e.clientX-r.left, e.clientY-r.top); }, {passive:false});

  // ===== Autosave profile =====
  function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
  function saveProfile(){
    const prof={ fio:fioEl.value.trim(), group:groupEl.value.trim(), difficulty:difEl.value };
    try{ localStorage.setItem('puzzleProfile', JSON.stringify(prof)); }catch{}
  }
  const debouncedSave = debounce(saveProfile, 300);
  fioEl.addEventListener('input', debouncedSave);
  groupEl.addEventListener('input', debouncedSave);
  difEl.addEventListener('change', saveProfile);

  try{
    const saved=JSON.parse(localStorage.getItem('puzzleProfile')||'{}');
    if(saved.fio) fioEl.value=saved.fio;
    if(saved.group) groupEl.value=saved.group;
    if(saved.difficulty && ['easy','medium','hard'].includes(saved.difficulty)) difEl.value=saved.difficulty;
  }catch{}

  // ===== Кнопки =====
  zoomInBtn.onclick  = ()=>{ const r=cv.getBoundingClientRect(); zoomAt(1.2, r.width/2, r.height/2); };
  zoomOutBtn.onclick = ()=>{ const r=cv.getBoundingClientRect(); zoomAt(1/1.2, r.width/2, r.height/2); };
  helpBtn.onclick = ()=> alert('Инструкция:\n• Перетаскивайте текущий субъект РФ из нижнего «лотка» на карту: потяните вверх за край лотка.\n• Масштаб/перемещение: колесо мыши; на телефоне — один палец панорамирование, два пальца — пинч-зум (макс. ×16).\n• Сложность фиксируется после установки первой детали.\n• «Вернуть деталь» — возвращает текущую незакреплённую деталь в лоток.\n• «Центрировать карту» — исходный вид.');
  returnBtn.onclick = ()=>{ const p=pieces[current]; if(!p.locked){ setPieceInTray(current, true); buildPick(); drawAll(true); } };
  centerBtn.onclick  = ()=>{ fitView(); if(!pieces[current].locked){ setPieceInTray(current, true); buildPick(); } drawAll(true); };

  document.getElementById('reset').onclick = ()=>{
    placed=0; placedEl.textContent=`0 / ${TOTAL}`; startAt=null; finished=false; timeEl.textContent='00:00';
    recolorProgress=0;
    for(const p of pieces){ p.locked=false; p.dx=0; p.dy=0; p.inTray=true; }
    order=d3.shuffle(d3.range(TOTAL)); cursor=0; difficultyLocked=false; difEl.disabled=false;
    fitProjection(); rebuildGeometry(); fitView(); setCurrent(order[cursor]); drawAll(true);
  };

  // ===== Leaderboards: 3 таблицы + фильтр по группе =====
  function msToMMSS(ms){ const s=Math.floor(ms/1000),m=Math.floor(s/60),ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }
  function q(s){ s=String(s||''); return `"${s.replace(/"/g,'""')}"`; }

  // Нормализация сложности на случай разнобоя в БД
  function normalizeDiff(d){
    if(d==='easy'||d==='medium'||d==='hard') return d;
    const t=String(d||'').toLowerCase();
    if(/легк/.test(t)||t==='e') return 'easy';
    if(/сред/.test(t)||t==='m') return 'medium';
    if(/высок|слож/.test(t)||t==='h') return 'hard';
    return 'easy';
  }

  // Берём лучший результат студента в разрезе «ФИО+группа+сложность»
  function bestPerFioGroupDifficulty(all, groupFilter){
    const res = { easy:[], medium:[], hard:[] };
    const byKey = { easy:new Map(), medium:new Map(), hard:new Map() };
    const gflt = (groupFilter||'').trim().toLowerCase();

    for(const r of all){
      const diff = normalizeDiff(r.difficulty);
      const fio  = (r.fio||'').trim();
      const grp  = (r.group||'').trim();
      if(gflt && !grp.toLowerCase().includes(gflt)) continue;

      const key = `${fio}|||${grp}|||${diff}`;
      const prev = byKey[diff].get(key);
      if(!prev || (r.time_ms||1e12) < (prev.time_ms||1e12)){
        byKey[diff].set(key, r);
      }
    }
    res.easy   = Array.from(byKey.easy.values()).sort((a,b)=> (a.time_ms||1e12)-(b.time_ms||1e12)).slice(0,50);
    res.medium = Array.from(byKey.medium.values()).sort((a,b)=> (a.time_ms||1e12)-(b.time_ms||1e12)).slice(0,50);
    res.hard   = Array.from(byKey.hard.values()).sort((a,b)=> (a.time_ms||1e12)-(b.time_ms||1e12)).slice(0,50);
    return res;
  }

  function renderTable(tbody, rows){
    tbody.innerHTML = rows.map((r,i)=>`<tr><td>${i+1}</td><td>${(r.fio||'')}</td><td>${(r.group||'')}</td><td>${msToMMSS(r.time_ms||0)}</td><td>${new Date(r.timestamp||Date.now()).toLocaleString()}</td></tr>`).join('');
    if(!rows.length){ tbody.innerHTML = `<tr><td colspan="5" style="color:#a9b7d6">Нет данных</td></tr>`; }
  }

  let ALL_RESULTS = [];
  function renderLeaderboards(all){
    ALL_RESULTS = all.slice(); // для CSV
    const buckets = bestPerFioGroupDifficulty(all, lbGroupEl.value);
    renderTable(tbEasy,   buckets.easy);
    renderTable(tbMedium, buckets.medium);
    renderTable(tbHard,   buckets.hard);
  }

  lbGroupEl.addEventListener('input', ()=> renderLeaderboards(ALL_RESULTS));

  // Экспортируем все «сырые» записи без фильтра (как просили)
  exportBtn.onclick = ()=>{
    const hdr=['fio','group','difficulty','time_mmss','time_ms','timestamp_iso','user_agent'];
    const lines=[hdr.join(',')].concat(ALL_RESULTS.map(r=>{
      const diff = normalizeDiff(r.difficulty);
      return [q(r.fio||''), q(r.group||''), diff, msToMMSS(r.time_ms||0), (r.time_ms||0), new Date(r.timestamp||Date.now()).toISOString(), q(r.user_agent||'')].join(',');
    }));
    const blob=new Blob([lines.join('\n')],{type:'text/csv;charset=utf-8;'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='puzzle_results_all.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),4000);
  };

  // Подписка на БД как и раньше — только теперь рисуем три таблицы
  const resultsRef = db.ref('results');
  resultsRef.on('value', snap=>{
    const val = snap.val()||{}; const all = Object.keys(val).map(k=>val[k]).filter(Boolean);
    renderLeaderboards(all);
  });

  // ===== Сохранение результата (без изменений) =====
  function persistResult(){
    const payload = {
      fio: (fioEl.value||'').trim(),
      group: (groupEl.value||'').trim(),
      difficulty: difEl.value,
      time_ms: Math.floor((performance.now() - startAt) || 0),
      placed, total: TOTAL,
      timestamp: Date.now(),
      user_agent: navigator.userAgent || ''
    };
    db.ref('results').push(payload).catch(err=>console.error('DB write error:', err));
  }

  // ===== Старт =====
  statusEl.textContent='Карта загружена';
  saveProfile();
  setCurrent(current); drawAll(true);
})();
</script>
</body>
</html>
